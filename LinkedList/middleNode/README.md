# 片方向リストの先頭 head が与えられるので、真ん中のノードを返す、middleNode というメソッドを作成する問題
真ん中のノードが 2 つ存在する場合は 2 つ目のノードを返すこと

## 例
入力が [1,2,3,4,5,6,7,8] の場合<br>
真ん中のノードは `4` と `5` の 2 つになる。この場合、2 つ目を優先させるので、答えは `[5,6,7,8]`<br>

## 使用するクラス
**Nodeクラス**<br>
プロパティ<br>
・`int data`: ノードのデータ<br>
・`Node next`: 次のノードの参照<br>

**SinglyLinkedListクラス**<br>
プロパティ<br>
・`Node head`: 先頭ノード<br>

**MiddleNodeLinkedListクラス**
SinglyLinkedListクラスを継承し、middleNodeメソッドを実装<br>


## テストケース
1. `MiddleNodeLinkedList.middleNode(SinglyLinkedList([1,2])) --> 2`<br>
2. `MiddleNodeLinkedList.middleNode(SinglyLinkedList([1,2,3,4,5,6,7])) --> 4➡5➡6➡7`<br>
3. `MiddleNodeLinkedList.middleNode(SinglyLinkedList([1,2,3,4,5,6,7,8]])) --> 5➡6➡7➡8`<br>
4. `MiddleNodeLinkedList.middleNode(SinglyLinkedList([14,35,8,4,97,33,53,68,23,1,84])) --> 33➡53➡68➡23➡1➡84`<br>


## 思考プロセス
**ゴール**
リストの先頭と末尾にデータを挿入した連結リストを返すこと<br>

**仮説**<br>
【必要な要素】<br>
①Nodeクラスの定義<br>
クラスの目的：Node単体の管理・操作<br>
用意するもの<br>
・データを保持する変数<br>
・次のデータを示すポインタを格納する変数<br>

②SinglyLinkedListクラスの定義<br>
クラスの目的：連結リストの管理・操作<br>
・先頭ノードを定義する<br>
・配列を順番に処理し、連結リスト化していく<br>
→ ループ処理によって配列の2番目の要素から、ノードのnextポインタを更新して連結していく<br>

③middleNodeメソッドの定義<br>
メソッドの目的：真ん中のノードにノードを返すこと<br>
・「真ん中のノードを特定する」<br>
→ 全探索しながら要素数をカウントしていく<br>
・「真ん中の数を求める」<br>
→ カウントした要素数を2で割り、小数点を切り捨て<br>
・「真ん中のノードまで走査する」<br>
→ ループ処理によって対象ノードまで進める<br>
・「真ん中のノードを返す」<br>

**検証**<br>
・自分が立てた仮説は検証できた<br>
・しかし、より効率的な方法があった<br>
→ fast & slow という、通常速度で進むポインタと2倍速で進むポインタを用意することで、ループ処理による全探索を1回で済ませる方法があったと他の方のコードからわかった<br>

## 悩んだ箇所
・真ん中のノードの特定方法<br>
→ 自分で立てた仮説に従い、ループ処理を2回行なうことで真ん中の位置を特定した<br>


## 直面したエラーと解決策
**エラー①**
`git push`コマンドが動作しない<br>
(原因) リモートから pull する前にステージング・コミットをしてしまったこと<br>
(解決策) rebase を使用<br>
詳しくは、以下の記事にまとめましたので、ご参照ください。<br>
参考：https://qiita.com/mabo23/items/6f4324a830eab1dd0694


## 気づき・学び
・ここまで問題で重複して使用しているクラスがあったため、クラスをまとめて定義しておき、継承する形式に変えたこと<br>
→ 1から何度も同じコードを書く必要がないため、その分の工数を減らすことができた<br>
・共通クラスを継承したクラスでコンストラクタを実装していなくても、親クラスのコンストラクタを呼び出せるため、インスタンス生成時には、その継承したクラスの型を指定できること<br>
・ツーポインタ(fast & slow)を使った方法があると知り、新たな方法を学んだと同時に、この方法は1回の全探索だけで済むので賢いと感じた<br>
・JavaScriptでメソッドをオーバーライドするときは、アノテーションなどが不要だったこと<br>


## 改善点・フィードバック
・効率性：1度のループ処理で真ん中のノードを見つけること<br>
・コードの簡潔さ<br>
