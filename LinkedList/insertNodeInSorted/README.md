# ソート済みの連結リストの先頭 head と、データ data が与えられるので、ノードを正しい位置に挿入した連結リストを返す、insertNodeInSorted という関数を作成する問題


## 【Node クラス】
#### プロパティ
`int data: 要素の値`   
`Node next: 1つ先のノード`  
next はデフォルトでは null を設定  

## 【SinglyLinkedList クラス】
#### プロパティ
`Node head: 先頭のノード`  
※固定配列を受け取り、コンストラクタ関数内で それぞれの Node の前後をつなげること  

## 【関数の入出力例】
`入力のデータ型： Node<integer> head, integer data`  
`出力のデータ型： Node<integer>`  


## 【テストケース】
1. `insertNodeInSorted(singlyLinkedList([2,10,34,45,67,356]),3) --> 2➡3➡10➡34➡45➡67➡356`  
2. `insertNodeInSorted(singlyLinkedList([2,10,34,45,67,356]),358) --> 2➡10➡34➡45➡67➡356➡358`  
3. `insertNodeInSorted(singlyLinkedList([2,10,34,45,67,356]),-5) --> -5➡2➡10➡34➡45➡67➡356`  
4. `insertNodeInSorted(singlyLinkedList([4,23,53,56,134,645]),34) --> 4➡23➡34➡53➡56➡134➡645`  
  

## 【考えられるエッジケース】
- head が null のケース  


## 【思考プロセス】
#### ◾️ゴール  
ソート済み連結リストに新たに生成したノードを正しい位置に挿入し、テストケースごとに正しく出力すること  

#### ◾️仮説（必要な要素）  
ゴールを達成するために必要な要素を整理  
  
1. Node クラスの定義  
- データを保持する変数  
- 次のノードを指し示すポインタを格納する変数  
  
2. SinglyLinkedList クラスの定義  
- 配列を引数としたコンストラクタを用意する  
- 先頭ノードを head 変数で管理する  
  
※ ①・②については、事前に[Common](../Common/js)に定義し、再活用しております  
  
3. 連結リストの中で data と同じ値を持つインデックスを返す関数を実装
**【目的】**
- ① 正しい位置にノードを挿入すること 
- ② 新しい連結リストを返すこと  
  
**【必要事項】** 
- data を使い、新しいノードを生成すること  
- 連結リストのノードと新しく生成したノードの値を比較すること  
- 連結リストのノードを次のノードに更新していくこと  
- 最適な位置にノードを追加すること  

#### ◾️検証  
- 方向性はあっていた
- しかし、実装の仕方が誤っていた  
- 具体的には、先頭に挿入する場合とそれ以外で分けて考える必要があった  

## 【悩んだ箇所】
- 先頭ノードにノードを挿入する方法  
- テストケースの3つ目がうまくいかないことから先頭に原因があるとまでは推定できたが、そこから条件をどうするのがいいのか自力で検討できなかった  

## 【直面したエラーと解決策】
**エラー①**  
```sh
if(newNode.data < currentNode.data){
                ^
TypeError: Cannot read properties of undefined (reading 'data')
```
(原因)  
ノードのデータが undefined でアクセスできないこと  
  
(解決策)  
条件の変更  

**エラー②**  
テストケースがターミナルに出力されない  
  
(原因)  
テストケースファイルにおけるテストケースの定義が違っていたこと  
  
(解決策)  
事前に作っていた共通関数を呼び出して、ターミナルに出力すること  

## 【気づき】
- 先頭ノードに挿入する条件についてわからず、AIに頼ってしまったが、そういうことかと発見もあった  
- 先頭ノードに挿入する時以外はまとめて表現できること  
- ループ条件に苦戦する傾向にあると気づいた  

## 【フィードバック・改善点】
- 先頭ノードが null または、head より小さいときはまとめて定義できる  
- この問題においては、temp という変数を用意しなくてもポインタを更新できる  
