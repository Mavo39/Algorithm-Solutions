# 配列 intArr と整数 k が与えられるので、サイズ k の連続する部分配列の最小値を返す minWindowArrK 関数を実装する問題


## 関数の入出力例
入力のデータ型： `integer[] intArr, integer k`  
出力のデータ型： `integer[]`  


## テストケース
1. `minWindowArrK([2,3,1,1,12,3,10],1) --> [2,3,1,1,12,3,10]`  
2. `minWindowArrK([2,3,1,1,12,3,10],3) --> [1,1,1,1,3]`  
3. `minWindowArrK([2,3,1,1,12,3,10],4) --> [1,1,1,1]`  
4. `minWindowArrK([3,9,10,2,4,5],3) --> [3,2,2,2]`  
5. `minWindowArrK([3,9,10,2,4,5],5) --> [2,2]`  
6. `minWindowArrK([30,50,60,20,30,64,80],3) --> [30,20,20,20,30]`  
7. `minWindowArrK([30,50,60,20,30,64,80],2) --> [30,50,20,20,30,64]`  
8. `minWindowArrK([24,5,67,60,24,64,23,536,345],3) --> [5,5,24,24,23,23,23]`  


## 思考プロセス
#### 【ゴール】  
minWindowArrK 関数を正しく実装し、テストケースをすべてクリアすること  

#### ◾️仮説  
**【関数の目的】**  
与えられたウィンドウサイズ k の連続する部分配列の最小値を返すこと  

**【必要な要素】**
1. 両端キュー  
- 両端キューを使用するため、Nodeクラス・標準メソッドを備えたDequeクラスが必要  
※ [code](../../../Deque/src/php/Deque)に実装し、再利用しています  
※ `03_getMaxWindow`を参考にしています

2. minWindowArrK 関数の実装  
- 結果を格納するための空配列の用意
- 配列が空のケースの対応
- 配列がウィンドウサイズに達していないケースの対応

3. Dequeクラスのインスタンスを生成し、メソッドを使う  
- Dequeでは配列のインデックスを管理する
- ループ処理により、要素をスライドしながら、ウィンドウ範囲外と対象外を選別する
- ループ処理は2回必要
(1)Dequeの初期化: 配列の先頭からウィンドウサイズまでの要素  
- 先頭に最小値に該当するインデックスを格納する
- → デックの末尾と配列の対象の値を比較し、比較対象の値が小さい場合に、デックの末尾をデキューする
(2)要素をずらしていく: ウィンドウサイズから配列の末尾までの要素  
- ウィンドウの範囲外かどうかのチェック
- 配列の値とデックの値の比較
- → (1)と同じ処理を行なう
- 結果を格納する配列に値を格納する


#### ◾️検証  


## 【悩んだ箇所】


## 【直面したエラーと解決策】  
  

## 【気づき】


## 【フィードバック・改善点】
