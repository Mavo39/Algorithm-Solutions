# 2 進数 bits が与えられるので 2 の補数を返す、twosComplement という関数を作成する問題。
条件<br>
・入力の 2 進数は 8 ビットとする。通常、回路はオーバーフローしたビットを保持することはできないが、今回は 00000000 の 2 の補数の最上位ビットを出力に含めること。<br>

## 関数の入出力例  
- **入力のデータ型**：`string bits`<br>
- **出力のデータ型**：`string`<br>

## テストケース
`twosComplement("00000000") --> 100000000`
`twosComplement("00000010") --> 11111110`
`twosComplement("11111111") --> 00000001`
`twosComplement("01110101") --> 10001011`
`twosComplement("00000001") --> 11111111`
`twosComplement("10000000") --> 10000000`
`twosComplement("10101010") --> 01010110`
`twosComplement("11111110") --> 00000010`

## 解き方
(1) 1の補数を求める<br>
(2) (1)の結果に1を足す<br>
・繰り上がりを考慮する必要があるため、変数で管理する。<br>
・繰り上がりを考慮するため、文字列の最後からループ処理を行なう。<br>
・ストップするポイントは2パターン<br>
① 桁が 0 の時<br>
その桁は 0 + 1 で 1 になる。繰り上がりはないので、carryOut は false にしておく。桁が 0 で 1 を足される場合、そこで全ての処理は終了するはずなので for loop を break する。<br>
② 桁が 1 の時<br>
その桁は 1 + 1 で 0 になる。繰り上がりが発生するので、carryOut を true にする。桁が 1 で 1 を足される場合、処理は終わらないため、for loop の最初に戻る。<br>
③ carryOut が true でこの for loop を抜けた場合<br>
twoComplement の全てのビットが 1 であったことを示し、全てのビットは 0 になっているはずなので、一番左端に 1 をプラスして処理を終了する。<br>

## 難しかったこと
・繰り上げの表現方法。<br>

## 試したこと
・1の補数を求め、1を文字列の末尾に加えていく処理を行なうこと<br>