# 整数によって構成される配列 arr が与えられるので、配列を受け取って逆向きの配列を返す、reverse という関数を Stack クラスを使って作成する問題


## 【Item クラス】
#### プロパティ
`int data: 要素の値`   
`Item next: 1つ先のノード`  
next はデフォルトでは null を設定  

## 【Stack クラス】
#### プロパティ
`Item head: 先頭のノード, デフォルトでは null に設定`  

#### メソッド
`void push(int data): スタックの先頭に Item を追加`  
`Integer pop(): スタックの先頭から Item を取り除き、その Item の値を返す。先頭が何も存在しない場合、null を返す。`  
`Integer peek(): スタックの先頭の Item の値を返す`  


## 関数の入出力例
入力のデータ型： `integer[] arr`  
出力のデータ型： `integer[]`  


## テストケース
1. `reverse([3,2,1,5,6,4]) --> [4,6,5,1,2,3]`  
2. `reverse([7,8,2,3,1,7,8,11,4,3,2]) --> [2,3,4,11,8,7,1,3,2,8,7]`  
3. `reverse([]) --> []`  
4. `reverse([1]) --> [1]`  
  

## 【思考プロセス】
#### ◾️ゴール  
Stackクラスを実装し、テストケースを正しく出力すること  

#### ◾️仮説（必要な要素）  
ゴールを達成するために必要な要素を整理  
  
1. Item クラスの定義  
- データを保持する変数  
- 次のノードを指し示すポインタを格納する変数  
  
2. Stack クラスの定義    
- 先頭ノードを head 変数で管理する  
- 各メソッドを指定された要件に基づき実装する
- メソッド1: push(ノードを追加)  
- メソッド2: pop(先頭ノードを取り出し)  
- メソッド3: peek(先頭ノードの値だけ出力)  

※ ①・②は[Common](../Common/js)に格納済み  

3. reverse 関数を実装
- 目的: 配列内の要素を逆にすること  
- 手順   
- ①スタックに配列の要素を順に格納する  
- ②スタックから要素を取り出しながら新たな配列に格納する  

#### ◾️検証  
- 方向性は合っていた  
- レビューを受けリファクタリングしたことで、可読性が改善した  

## 【悩んだ箇所】
- 悩んだ箇所はなかった    

## 【直面したエラーと解決策】
**エラー①**  
出力結果がすべて空 []  
  
【原因】  
- 2つ目のループ処理の条件を stack の長さにしていたこと  
- stack の長さにすることによって、pop するたびに、長さが短くなってしまう  

【気づいたきっかけ】  
- ループ処理の条件を arr の長さに変えた時に動作したところから  

【解決策】  
- ループ条件を配列の長さにする  

## 【気づき】
- リファクタリングによって当初自分で書いたコードよりも明らかに読みやすくなった  
- コードによってなぜループ処理が必要なのかの意図が読み解くことができた  
- コードで1以上のことを伝えられる力を知った  

## 【フィードバック・改善点】
① 1つ目のループ処理を for ... of 構文を使って表現すること  
- この改善により、インデックス操作（arr[i]）を使わないので、誤って範囲外アクセスやミスが起きにくくなることが期待できた  
- 可読性が改善した  
```js
// 改善前
for(let i = 0; i < arr.length; i++){

}

// 改善後
for(const ele of arr){

}
```
  
② whileループを使って、スタックが空になるまでチェックする  
- これにより、「配列の長さ分処理をする」というコードよりも「スタックが空になるまで」チェックする意図が明確になった  
- また、先頭ノードを取り出すわけではないため、安全性が確保された  
```js 
// 改善前
for(let i = 0; i < arr.length; i++){

}

// 改善後
while (stack.peek() !== null){

}
```