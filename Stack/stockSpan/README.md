# 各日の株価を表す整数の配列 stocks が与えられるので、各日の i 日から何日前まで連続でその i 日の価格より高いかを配列で返す、stockSpan という関数を作成する問題
ただし、株価の上昇には同じ日を含む

### 例: [1,2,5] → [1,2,3] 
1日目は 1、2日目は 1、2 と 2連続、3日目は 1, 2, 5 と 3連続で株価が上昇しているため

## 関数の入出力例
入力のデータ型： `integer[] stocks`  
出力のデータ型： `integer[]`  


## テストケース
1. `stockSpan([30,50,60,20,30,64,80]) --> [1,2,3,1,2,6,7]`  
2. `stockSpan([24,5,67,60,24,64,23,536,345]) --> [1,1,3,1,1,3,1,8,1]`  
3. `stockSpan([200,85,40,60,40,65,90]) --> [1,1,1,2,1,4,6]`  
4. `stockSpan([30,45,20,100,235,300,4500,40,100]) --> [1,2,1,4,5,6,7,1,2]`  
5. `stockSpan([34,640,100,234,56,34,25,200,1020,160]) --> [1,2,1,2,1,1,1,4,9,1]`  


## 【思考プロセス】
#### 【ゴール】  
現在の株価が連続して前の日より大きかったかを配列として正しく返すこと

#### 【目的】
今の株価が、どれだけ連続して前の日よりも大きかったか、または、同じだったかを求めて、配列として返すこと  
  
#### 【必要タスク】
1. スタックの用意
- 目的: 過去の株価に対応するインデックスを管理する
- 理由: 直近の株価との比較を高速に行なうため
- 内容: スタックには インデックス（整数） を格納する
→ インデックスがあれば、stocks[i] でその日の株価も参照できる
→ results[i] でその日のスパンも参照できる

2. 各日の株価に対して処理を行う（ループ）
2-1. 現在の株価が、スタックトップ（＝過去の株価）より大きい場合  
- 処理: スタックのトップをポップする
- 理由: 自分より小さい（または同じ）株価の日は、今のスパンに含めることができるから
- 追加処理: ポップしたインデックスに対応する `results[そのインデックス]` の値を、連続日数を管理する変数に加える  
→ 過去の連続したスパンをまとめて吸収できる  
→ スパンはすでに「何日連続で大きいか」の情報を持っているため、再計算不要  

2-2. 現在の株価が、スタックトップより小さい（または同じ）場合  
- 処理: ポップせず、そのまま終了
- 理由: それ以上先にはスパンが広がらない「境界線」だから

3. スパンの結果を記録し、スタックに現在のインデックスを push
- results[i] = 連続日数を管理する変数（吸収した分＋自分自身でスパンを構成）
→ このようにして、連続日数の結果を、配列 `results` の i 番目（＝その日のインデックス）に対応させて記録する
- stack.push(i)（この日が今後の比較の基準になる）
 
#### 【検証】  


## 【悩んだ箇所】


## 【直面したエラーと解決策】


## 【気づき】


## 【フィードバック・改善点】
