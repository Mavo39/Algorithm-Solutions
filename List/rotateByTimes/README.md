# Glover はくじ引きで数字をランダムに引いて、その数だけ住人が部屋をずらすルールがあるシェアハウスに住んでおり、定期的に部屋替えを行なっている。住人たちの ID をまとめた ids と、くじ引きで引いた自然数 n を引数として、住人の位置をずらさせた配列を返す、rotateByTimes という関数を定義する問題

## 例
数字 2 を引いたとき: 部屋番号 1 に住んでいる人は 3 に移動する。<br>

## 関数の入出力例
入力のデータ型： `integer[] ids, integer n`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`rotateByTimes([1,2,3,4,5],2) --> [4,5,1,2,3]`<br>
`rotateByTimes([1,2,3,4,5],5) --> [1,2,3,4,5]`<br>
`rotateByTimes([10,12,3,4,5],3) --> [3,4,5,10,12]`<br>
`rotateByTimes([4,23,104,435,5002,3],26) --> [5002,3,4,23,104,435]`<br>
`rotateByTimes([4,23,104,435,5002,3],0) --> [4,23,104,435,5002,3]`<br>
`rotateByTimes([4,23,104,435,5002,3],1) --> [3,4,23,104,435,5002]`<br>
`rotateByTimes([4,23,104,435,5002,3],2) --> [5002,3,4,23,104,435]`<br>
`rotateByTimes([2,3],1) --> [3,2]`<br>

## 思考プロセス
・「ラウンドロビン」のとき同様、指定された数字を現在のインデックスに足してずらしていくこと<br>
→ 要素数を求める<br>
→ インデックスに足していくが、そのインデックスが`要素数-1`を超えた場合に循環させる必要がある（インデックスの最初からスタートするようにする必要がある）<br>
→ 条件分岐で `現在のインデックス + n > 要素数 - 1` のときにインデックスの最初に戻るよう、余りの考え方を使う<br>
→ 各要素に対して検証する必要がある<br>

・現在比較しているインデックス（ループのカウンタ）とその反対位置にあるインデックスを求める必要がある<br>
→ 例えば、[1,2,3,4,5,6]という配列があった場合、1の反対サイドは6、2の反対サイドは5、3の反対サイドは4となる<br>
→ これをどうやって表現するか<br>
→ ループカウンタはループ処理ごとに指定位置から後ろに動いていく<br>
→ 後ろのインデックスは真ん中に向かって動く、つまり、インデックスの値を小さくしていく必要がある<br>
→ end - i(指定位置の最後 - ループカウンタ)で指定範囲のスタート位置からの距離を求めることができる<br>
→ end - iだけだと、指定範囲におけるスタート位置からの距離であって、スタート位置の反転にはならない<br>
→ startに足していくことで反対サイドを表現できる<br>

## 悩んだ箇所
・配列に格納する順番<br>
→ 引数の配列は1つの要素から見ていくが、この1つ目の要素を最初に新しい配列に格納すると、2つ目以降の要素の格納順番を制御する必要が出てきてしまう<br>
→ 新しい配列のインデックス0の位置にきた既存配列の要素からループできれば順番通り処理できるが、今回はそうはいかない<br>
→ 固定長配列なら問題ないが、今回はそうはいかない<br>

## 解決策
回答動画を視聴し、考え方を学習した<br>
① 配列の後ろからn(n % 配列の要素数)分配列の先頭に持ってくる<br>
※ unshift()によって、都度要素をずらす必要があるため、計算量が増えてしまう<br>

② inplaceアルゴリズムを活用する<br>
具体的には、<br>
文字列全体を逆表示する<br>
→ インデックスn(n % 配列の要素数)番目まで逆表示する（元に戻すイメージ）<br>
→ 残りの要素を逆表示する<br>

## 計算量
PHP<br>
(予想)時間計算量：O(n)　空間計算量：O(1)<br>
・時間計算量：ループ処理が要素数分あるため<br>
・空間計算量：新たなメモリ消費が発生していないため<br>
(結果)時間計算量：O(n)　空間計算量：O(1)<br>

JavaScript<br>
時間計算量：O(n)　空間計算量：O(1)<br>
※inplaceアルゴリズムを使っているため、引数の配列に直接変更を加えている点には注意<br>

## 気づき
・配列内の要素を逆表示し、最初の要素から指定位置の要素まで・指定位置の要素から最後の要素までをそれぞれ逆表示することで表現できるということ<br>
・実際に逆表示のロジックを実装してみて斬新だった。また、逆表示のロジックを参考にしながら実装できたことで、処理の流れが理解できた<br>

## 改善すべき点
・時間計算量<br>
・簡潔さ<br>
※ この問題は完全自力では解けなかったため、明日4.18も別解でチャレンジする<br>
→ 4.18 逆表示のロジックを使って実装<br>
