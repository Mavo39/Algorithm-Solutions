# 整数で構成される配列 arr が与えられるので、マージソートアルゴリズムを実装し、配列を昇順で返す mergeSort という関数を作成する問題


## 関数の入出力例
入力のデータ型： `integer[] arr`<br>
出力のデータ型： `integer[]`<br>


## テストケース
`mergeSort([2,12,5,10,9,8]) --> [2,5,8,9,10,12]`<br>
`mergeSort([1,5,3,4,3,1,6]) --> [1,1,3,3,4,5,6]`<br>
`mergeSort([11,45,32,75,88,15,15]) --> [11,15,15,32,45,75,88]`<br>


## 思考プロセス
ゴール: 分割統治法を用いてマージソートを実装すること<br>
必要な要素: ①分割統治法の妥当性推測 ②分割 ③制覇 ④統合<br>

①分割統治法の妥当性推測<br>
・この問題は配列の要素が1つになるまで配列を半分に分割する<br>
・要素が1つになったとき、その要素を配列で返す<br>
・返された配列を左右で比較し、並び替え（比較→並び替え→結合）<br>
・繰り返していくことで、並び替えがされた配列ができそう<br>
→ 分割統治法が適用できると判断<br>

② 分割<br>
配列を半分に分ける操作を配列の要素が1つになるまで行なう<br>
→ 結果を呼び出し元に戻す必要があるため、再帰を使用する<br>
・start と end というインデックスを使って範囲を指定<br>
・真ん中 mid = (start + end) / 2 を基準にして左右に分ける<br>
・配列を半分に分ける操作を配列の要素が1つになるまで行なう<br>

③ 制覇<br>
小さくなった問題、要素1個を直接解く<br>
・ベースケース: start と endインデックスが同じとき、その要素を配列として返す<br>

④ 統合<br>
小さな答えである要素を含んだ配列を左右で比較し、小さい方を配列に先に加えて全体の答えにする<br>
・再帰ケース: 小さな問題の解を呼び出し元に返す（比較→並び替え→結合を繰り返す）<br>

## 考えられるエッジケース
・引数が空配列<br>


## 悩んだ箇所
・問題に取り組む前に過去のマージソートロジックについて復習をしたため、そこまで手が止まることはなかった<br>


## 計算量
JS<br>                                                                        
(予想)時間計算量：O(n log n)　空間計算量：O(n)<br>
・時間計算量：計算量 = 各段階の処理回数 × 段階の数（深さ）で、深さが log n、この処理が各階層で n 回あるため<br>
・空間計算量：配列を返すたびにメモリを消費するため<br>
(結果)時間計算量：O(n log n)　空間計算量：O(n)<br>
・<br>

## 直面したエラーと解決策
・なし<br>


## 気づき
・インデックスの増加を他の処理と一緒に記述できること（後置インクリメント）<br>
→ 後置インクリメントは使った後に増やす<br>


## 改善点・フィードバック
・後置インクリメント<br>
・冗長なコード<br>
```js
    // 改善前
    if(leftArr[leftIndex] <= rightArr[rightIndex]){
        merged.push(leftArr[leftIndex]);
        leftIndex++;
    }
    else {
        merged.push(rightArr[rightIndex]);
        rightIndex++;
    }
```
```js
    // 改善後
    while(li < leftArr.length - 1 || ri < rightArr.length - 1){
    if(leftArr[li] <= rightArr[ri]){
        merged.push(leftArr[li++]);
    } else {
        merged.push(rightArr[ri++]);
    }
```