# 自然数 n が与えられるので、1 から n までに含まれる素数を配列として返す primeArray という関数を作成する問題

## 関数の入出力例
入力のデータ型： `integer n`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`primeArray(97) --> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]`<br>
`primeArray(1) --> []`<br>
`primeArray(2) --> [2]`<br>

## 解き方
・素数判定を行なう関数を用意する<br>
・空の配列を用意し、ループ処理により素数と判定された数を配列に格納していく<br>

## 計算量
JavaScript<br>
(トータル)時間計算量：O(n^2) 空間計算量：O(n)<br>
・時間計算量：primeArray関数のループ処理内で計算量O(n)のisPrimeを呼び出すことで、間接的にネストされたループとなるため<br>
・空間計算量：結果を格納する配列のサイズは、素数の個数に依存するため<br>
<br>
(isPrime)時間計算量：O(n)　空間計算量：O(n)<br>
・ループ処理によりnまで走査<br>
<br>
PHP<br>
(トータル)時間計算量：O(n √n)　空間計算量：O(n / log n)<br>
・時間計算量：n回のisPrime()の呼び出し * 各isPrime()の呼び出し<br>
・空間計算量：O(n)と考えていたが、実際に保持するのは素数だけなので、素数定理より上記になるとのこと<br>
(isPrime)時間計算量：O(√n)　空間計算量：O(1)<br>
・時間計算量：3からはnの平方根まで走査<br>
・空間計算量：追加のメモリを消費しない<br>

## 気づき
・計算量を考えるときは、個別関数ごとに計算量を求め、最終的にその総和を考えること<br>
・これまでJSフォルダを`js`ではなく`javascript`で作成していたこと<br>
・bool型は1ビット（実際は1バイトのようだ）の固定サイズで、引数の大きさに依存しないこと<br>

## 工夫した点
・素数判定のロジックをメイン関数外に実装したことにより、ロジックを分離したこと。<br>

JavaScript<br>
・テンプレートリテラルを使用し、1行で結果を出力したこと<br>
console.logによるコンソール出力では、配列が長くなる場合に自動的に改行されていた<br>

PHP<br>
・前回のJavaScriptのコードで時間計算量がO(n^2)となっていた点を、素数判定のロジックを改善することで削減できたこと<br>
・偶数、つまり2の倍数のときは素数になり得ないということを活かして、ループ処理において偶数をスキップする更新式にしたこと<br>

## 改善すべき点
共通
・大規模なデータを処理するケース<br>
<br>
JavaScript
・時間計算量O(n^2)を削減すること<br>

