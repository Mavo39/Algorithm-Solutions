# 数値が格納された配列 intArr が与えられるので、全ての奇数番目を足した値を返す addEveryOtherElement という関数を定義する問題

## 関数の入出力例
入力のデータ型： `integer[] intArr`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`addEveryOtherElement([34,46,45,57]) --> 79`<br>
`addEveryOtherElement([60,45,66,75,56,32,654,45,100]) --> 936`<br>
`addEveryOtherElement([5,10]) --> 5`<br>
`addEveryOtherElement([120,85,45,67,54,343,57,800,88,67,56,57,68,75]) --> 488`<br>
`addEveryOtherElement([]) --> 0`<br>

## 思考プロセス
・引数が空だった場合を先に処理する<br>
・配列の奇数番目はインデックスの偶数番目に該当する<br>
→ ループ処理で加算を行なう際に、更新式を2ずつ増やしていく<br>
→ こうすることで、配列内のすべての要素を走査せずに済む<br>
→ 時間計算量を全要素を走査する場合の半分に減らすことができる<br>


## 計算量
JavaScript<br>
(予想)時間計算量：O(n) 空間計算量：O(1)<br>
(判断根拠)<br>
・時間計算量：ループ処理を1度行なう、配列の要素数に依存するため<br>
ただし、全要素を操作する必要はないため、厳密にはO(n/2)となると考えられる。が、定数倍は無視されるため、上記の計算量になると判断した。<br>
・空間計算量：一度用意した変数内で値を更新し、追加のメモリ消費がないため<br>

<br>

PHP<br>
時間計算量：O(n)　空間計算量：O(1)<br>
・時間計算量／空間計算量の判断根拠はJavaScriptと同じ<br>

## 工夫した点
・更新式でインデックスを2ずつ追加することで時間計算量を全要素の走査の半分に抑えたこと<br>

## 感想
・問題として特につまづく箇所はなかった。リソースは有限であるため、効率は大事だと思った。