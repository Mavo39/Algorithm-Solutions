# 兄の注文リスト listA と Whalum の注文リスト listB が与えられるので、兄が買うもので Whalum の注文リストに入ってないものを返す、missingItems という関数を定義する問題
ただし、被りが一切存在しない時は、兄の注文リストをそのまま返すこと<br>


## 関数の入出力例
入力のデータ型： `integer[] listA, integer[] listB`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`missingItems([1,2,3,4,5,6,7,8],[1,3,5]) --> [2,4,6,7,8]`<br>
`missingItems([1,2,3,4,5],[1,2]) --> [3,4,5]`<br>
`missingItems([1,1],[2,2]) --> [1,1]`<br>
`missingItems([9,8,7,6,5],[1,2]) --> [9,8,7,6,5]`<br>
`missingItems([1,2],[9,8,7,6,5]) --> [1,2]`<br>
`missingItems([3,4,5,1,2],[1,2]) --> [3,4,5]`<br>
`missingItems([8,3,45,67,23,9,3],[5,7]) --> [8,3,45,67,23,9,3]`<br>
`missingItems([8,3,45,67,23,9,3],[5,45]) --> [8,3,67,23,9,3]`<br>
`missingItems([8,3,45,67,23,9,3],[3]) --> [8,45,67,23,9]`<br>
`missingItems([8,3,45,67,23,9,3],[]) --> [8,3,45,67,23,9,3]`<br>

## 思考プロセス
・2重ループは避けたい<br>
・この問題のゴールは、兄のリストにあってWhalumのリストにないもののリストを作ること<br>
→ 必要なものは、照合する元と照合先<br>
→ 兄のリストをハッシュマップに保存し、Whalumのリスト内の要素があるかを探索する<br>
→ 同じ数字がリスト内に存在する場合どうするかについて考えていなかった<br>
→ 数字の回数をカウントし、減らすことも視野に入れる<br>


## 考えられるエッジケース
・どちらかの配列が空<br>


## 悩んだ箇所
・特になかった<br>


## 計算量
JS<br>                                                                        
(予想)時間計算量：O(n)　空間計算量：O(n)<br>
・時間計算量：ループ処理による全探索が2回あるが、定数は無視されるため<br>
・空間計算量：配列作成時に要素の追加があるため<br>
(結果)時間計算量：O(n+m)　空間計算量：O(n)<br>
・2つリストの長さが同じとは限らないため、長さを考慮してn+mになる<br>


## 直面したエラーと解決策
・出力結果が最後のテストケース以外違う<br>
→ 他のテストケースはほぼ兄のリストの方が長い<br>
→ Whalumのリストの長さで終了してしまうと、兄のリストを全探索できない可能性が高い<br>
→ 兄のリストは取りこぼしがないよう全探索する必要がある<br>
→ 当初の思考プロセスとは逆で、Whalumのリストをハッシュマップ化する必要があった<br>


## 気づき
・実装しながら異変に気づき修正することができた<br>
・時間計算量を導き出すときに、2つのリストの長さが同じか否かを考慮する視点が抜けていた<br>
・フィードバックで、確かに、わざわざハッシュマップにしなくてもできるならその方が効率的だと感じた<br>


## 改善点・フィードバック
・JavaScriptの場合、キーの存在確認だけを目的とするなら Set の方が意味的に明確<br>
・長さを変数に代入しなくても処理速度に影響はない<br>
