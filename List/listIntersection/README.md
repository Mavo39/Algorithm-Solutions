# 数値で構成される配列 targetList と searchList が与えられるので、両方のリストの全ての交点を返す listIntersection という関数を定義する問題
ただし、交点は昇順で重複がない状態で返すこと

## 関数の入出力例
入力のデータ型： `integer[] targetList, integer[] searchList`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`listIntersection([1,2,3,4,5,6],[1,4,4,5,8,9,10,11]) --> [1,4,5]`<br>
`listIntersection([3,4,5,10,2,20,4,5],[4,20,22,2,2,2,10,1,4]) --> [2,4,10,20]`<br>
`listIntersection([2,3,4,54,10,5,9,11],[3,10,23,10,0,5,9,2]) --> [2,3,5,9,10]`<br>

## 思考プロセス
・2つのリストで共通の値のリストを作成する<br>
→ ハッシュマップを使い、2重ループを回避する<br>
・交点は昇順で重複がない状態で返すという条件をクリアするために<br>
→ 引数の配列を昇順にする<br>
※searchListのみ並び替えればいい<br>
→ 一度ハッシュマップに格納した値は格納しない<br>

## 考えられるエッジケース
・引数のいずれかの配列が空配列<br>

## 悩んだ箇所
・「既に存在する場合」をどう表現するか<br>
→ in_array(), isset()<br>
・重複が発生した原因解明とその解決策

## 気づき
・in_array()のisset()の計算量の違いについて、内部処理からわかったこと<br>
→ in_array(): 配列を全探索する O(n)<br>
→ isset(): 指定したキーが存在するかどうかをチェックするだけ O(1)<br>
・他の方のコードから、foreachを使った方が可読性がいいとわかったこと<br>

## 計算量
PHP<br>                                                                        
(予想)時間計算量：O(n)　空間計算量：O(n)<br>
・時間計算量：ハッシュマップ作成時のループ処理による全探索が一度行われるため<br>
・空間計算量：hashmap作成時に、ハッシュマップ配列に対して要素分の追加があるため<br>
(結果)時間計算量：O(n^2)　空間計算量：O(n)<br>
・in_array()によってループ内でループを行なっている状態のため<br>

## 直面したエラーと解決策
・Warning: Undefined array key 5 in ~ solution.php on line 15<br>
→ is_null()を使用してハッシュマップ内に値が存在するかを確認していた<br>
→ in_array()に変更<br>

・`[4,10,2,20,4]`, `[2,3,10,5,9]`と出力結果がソートされていない、重複がある<br>
→ 出力結果がソートされていない: 引数ではなく結果をソートする<br>
→ 重複がある: ハッシュマップを作成する段階で、同じ数字があるときは配列に格納しないようにする<br>
→ in_array()を使っていたが、isset()に変更<br>
→ in_array(): 配列を全探索する O(n)<br>
→ isset(): 指定したキーが存在するかどうかをチェックするだけ O(1)<br>

・Notice: Only variables should be passed by reference in ~ solution.php on line 18<br>
→ array_unique()をつかうとき、関数の戻り値のような変数以外を直接渡すのはダメということ = 変数のみ渡すことができる<br>
→ 重複を消そうとしてarray_unique()を試した<br>

・isset()を使用しても重複が発生する<br>
→ targetListを走査する際、「ハッシュマップに値が存在する場合」という条件になっている<br>
→ targetList自体に同じ値が他にあっても成立してしまう（ここが原因）<br>
→ `if(isset($hashmap[$targetList[$i]]) && !isset($res[$targetList[$i]]))`に変更<br>
→ これでも重複が発生する<br>
→ $resは連想配列ではなく、通常の配列として使用されることが想定されているため、重複できない<br>
→ in_array()を使用する<br>


## 改善点
・計算量の削減<br>
