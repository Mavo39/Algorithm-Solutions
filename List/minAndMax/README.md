# あるアパレルショップでは、服を複数購入した場合、1 点だけ無料にするセールを行なっていました。購入する服の値段がまとめてある intArr が与えられるので、1 点無料になった際の合計の金額を返す、minAndMax という関数を作成する問題
条件：無料になる服が購入するものの中で最も高いものの場合と、安いものの場合の 2 つを返すこと<br>

## 関数の入出力例
入力のデータ型： `integer[] intArr`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`minAndMax([5,3,2,3,4]) --> [12,15]`<br>
`minAndMax([5,3]) --> [3,5]`<br>
`minAndMax([5,0,1]) --> [1,6]`<br>
`minAndMax([5,5,5,5,5]) --> [20,20]`<br>
`minAndMax([10,80,40,60,70]) --> [180,250]`<br>
`minAndMax([700,500,300,900,600,80,320,780,1000]) --> [4180,5100]`<br>

## 解き方
・`[①, ②]`としたとき、①:全合計 - 最も高い服、②:全合計 - 最も安い服<br>
・最も高い服 と 最も安い服を表すインデックスを管理する<br>
・結果を配列に格納する<br>

## 計算量
JavaScript<br>
・時間計算量：O(n) 空間計算量：O(1)<br>
(判断根拠)<br>
・時間計算量：ループ処理を1度行なう、配列の要素数に依存するため<br>
・空間計算量：新たなメモリ消費がなく一定であるため<br>
※厳密には追加メモリを使用しているが、実質O(1)と変わらないという解説だった。<br>
→ res配列（返却用、要素数2で固定）<br>
→ sum, minIndex, maxIndex変数（固定サイズ）<br>
→ ループカウンタi（固定サイズ）<br>

<br>

<!-- PHP<br>
(トータル)時間計算量：O()　空間計算量：O()<br>
・時間計算量：<br>
・空間計算量：<br> -->


## 気づき
・スプレッド構文はシャローコピーを行なうこと。ネストされた配列やオブジェクトはコピーできないこと<br>
・スプレッド構文を使用したときに、どのようにメモリの使われ方をするのかを知ったこと<br>
・スプレッド構文によって配列を展開すると、配列の全要素の走査が必要で、配列の各要素を個別の値として分離し、新しい形式にコピーして表現するため、要素数に比例した追加メモリが必要になること。対して、ループ処理は既存の配列メモリを直接参照するため、新たなメモリの確保がほとんどいらない。<br>

## 工夫した点
・スプレッド構文を調べて使おうと考えたが、メモリ使用量を考慮してループ処理で実装したこと<br>
・はじめ、目的別にループを実装しようとしていた。配列内の要素の合計値を求めるループ、最大値・最小値を表すインデックスを求めるループでそれぞれ実装しようとしていたが、まとめられるのではと思い、1つにまとめた。

## 改善すべき点


