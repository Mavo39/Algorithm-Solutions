# ユーザーが解いたことのある問題一覧が、小文字のアルファベットから成る文字列 s として与えられるとき、この文字列内で最初に出現し、かつ一度しか解かれていない問題のインデックスを返す firstNonRepeating という関数を定義する問題
このような問題が存在しない場合は -1 を返すこと<br>

## 例
文字列が "aabbcdddeffg" の場合: 一度しか解かれていない最初の問題は c で、そのインデックスは 4 なので 4 を返す。


## 関数の入出力例
入力のデータ型： `string s`<br>
出力のデータ型： `integer`<br>


## テストケース
`firstNonRepeating("aabbcdddeffg") --> 4`<br>
`firstNonRepeating("abcdabcdf") --> 8`<br>
`firstNonRepeating("abcddaebcdf") --> 6`<br>
`firstNonRepeating("aabbbccdd") --> -1`<br>
`firstNonRepeating("ddecdfgf") --> 2`<br>
`firstNonRepeating("abcdeeff") --> 0`<br>
`firstNonRepeating("zzcbdefghafhgbbcd") --> 5`<br>


## 思考プロセス
#### ゴール
1度だけ登場した文字のインデックスを返すこと<br>

#### 必要な要素
①ハッシュマップの作成<br>
各文字の登場回数をカウントする<br>

②値「1」の検索<br>
・ループ処理を行ない、最初に値が 1 になったタイミングで処理を終了するよう設計する<br>
→ こうすることで、全探索を行なわずに済む可能性がある<br>
・ただし、この方法で1回しか登場しない文字は見つかるが、その文字のインデックスを取得するには別の手段を用意する必要がある<br>

③値「1」のインデックスを求める<br>
strposを使って、値「1」の場所を求める<br>


## 考えられるエッジケース
・文字列が空<br>


## 悩んだ箇所
・特になかった<br>


## 計算量
PHP<br>                                                                        
(予想)時間計算量：O(n+m)　空間計算量：O(n)<br>
・時間計算量：ループ処理が2回あるが、定数は無視されるため<br>
・空間計算量：ハッシュマップ作成に伴う追加のメモリ消費があるため<br>
(結果)時間計算量：O(n+m)　空間計算量：O(n)<br>


## 直面したエラーと解決策
・エラー自体はなかった<br>


## 気づき
・コードレビューを受けて可読性を改善するために、null合体演算子を調べ使ってみた<br>
→ if 文の長さが短くなり、改善したことが実感できた<br>
・ネストの深い配列リテラル（多次元配列）をなるべく避けるようにコーディングすることが重要だとわかったこと<br>
→ ①変数に分ける ②改行+インデント ③連想配列にして構造化 といった手段がある<br>
・ハッシュマップとforeachの相性がいいこと><br>
・ハッシュマップのキーのみにアクセスしてループ処理をするためにarray_keys()を使えると気づいた<br>
・最初にインデックスを格納する変数を使っていたが、更新してから変数を返すのはこの問題においては効率が悪いとわかった<br>


## 改善点・フィードバック
・null合体演算子 (??)を使った記述<br>
```php: 改善前
    foreach($hashmap as $key => $value){
        if($value === 1){
            $index = strpos($s, $key);
            return $index;
        }
    }
```
```php: 改善後
    for($i = 0; $i < $length; $i++){
        if($hashmap[$s[$i]] === 1){
            return $i;
        }
    }
```
もともとforeachを使っていたが、for文で文字列の最初から操作することでインデックスをすぐに求めることができる<br>