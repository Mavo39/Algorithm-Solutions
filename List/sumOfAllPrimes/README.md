# 自然数 n が与えられるので、素数の和を返す sumOfAllPrimes という関数を定義する問題
エラトステネスの篩を使った実装

## 関数の入出力例
入力のデータ型： `integer n`<br>
出力のデータ型： `integer`<br>

## テストケース
`sumOfAllPrimes(1) --> 0`<br>
`sumOfAllPrimes(2) --> 2`<br>
`sumOfAllPrimes(3) --> 5`<br>
`sumOfAllPrimes(100) --> 1060`<br>
`sumOfAllPrimes(1000) --> 76127`<br>

## 思考プロセス
・エラトステネスの篩をつかう<br>
→ n まで true を格納した配列を作る（サイズnの配列）<br>
→ 2以上nの平方根までループ処理を行ない、2以上の数字の倍数をfalseにしていく<br>
→ 最終的に配列に残ったtrueのインデックスは素数と判定され、最後に配列内の要素を足すことで求めることができる<br>
→ ただし、0と1は素数でないので、初期の段階でfalseに設定しておく<br>

## 考えられるエッジケース
・n が0未満のケース<br>

## 悩んだ箇所
・特になかった。<br>

## 計算量
JS<br>                                                                        
(予想)時間計算量：O(n)　空間計算量：O(n)<br>
・時間計算量：ループによる線形探索が2回あるが定数は無視されるため<br>
・空間計算量：n回分配列に要素を追加するため<br>
(結果)時間計算量：O(n log log n)　空間計算量：O(1)<br>
※厳密には時間計算量がO(n log log n)になるが、O(n)でも問題ないらしい。<br>

## 気づき
・キャッシュを使った考え方が斬新だったこと<br>
一旦すべてtrueにし、あとからfalseに更新する。<br>

## 改善点
・fillメソッドの活用により、可読性を向上させる<br>