# 地震前の荷物 arr と地震後の荷物 shuffledArr が与えられるので、地震が起きた後に何%の荷物が移動したかを返す、shuffleSuccessRate という関数を定義する問題

## 条件
・小数点以下は切り捨ての処理を行なうこと<br>
・商品番号は一意である<br>

## 関数の入出力例
入力のデータ型： `integer[] arr, integer[] shuffledArr`<br>
出力のデータ型： `integer`<br>

## テストケース
`shuffleSuccessRate([2,32,45],[45,32,2]) --> 66`<br>
`shuffleSuccessRate([2,32,45],[45,2,32]) --> 100`<br>
`shuffleSuccessRate([2,32,45],[2,32,45]) --> 0`<br>
`shuffleSuccessRate([2,32,45,67],[2,32,67,45]) --> 50`<br>
`shuffleSuccessRate([2,32,45,67,89],[2,89,67,45,32]) --> 80`<br>
`shuffleSuccessRate([119,726,398,187,943,486,728,305,968,754,650,536,969,305,111,225,708,806,40,969],[708,969,111,398,754,726,536,943,486,305,969,40,650,806,187,225,968,119,728,305]) --> 95`<br>

## 思考プロセス
・基本的な考え方は「配列のシャッフル」と同じ<br>
・何個の要素のインデックスが変化したかを知る必要がある<br>
・地震後の配列の数字をキー、インデックスを値としてハッシュマップを作成する<br>
→ 作成したハッシュマップに地震前の配列 arr を走査しながら検索し、走査中のインデックスとハッシュマップの値（インデックス）が一致しなかった場合に変数をカウントする<br>
→ カウントした変数の値を配列の要素数で割り、割合を求める<br>

## 考えられるエッジケース
・arr が空配列<br>
・shuffledArr が空配列<br>

## 悩んだ箇所
・特になく、すぐにハッシュマップによるアクセスが効率的だと勘付いた<br>

## 気づき
・floor関数を使わずに、intでキャストする方法があること<br>
・前回の問題で学んだことを活かすことができたこと<br>
→ 変数をなるべく新たに作成せず、使いまわせるなら使いまわせるようにするため、最初に変数を宣言した<br>

## 計算量
PHP<br>                                                                        
(予想)時間計算量：O(n)　空間計算量：O(n)<br>
・時間計算量：ループによる線形探索が最大2回あるが、ハッシュマップ作成時のループが対象になるため。2回目のループはO(1)アクセスになる<br>
・空間計算量：hashmap配列に、配列の要素分の追加があるため<br>
(結果)時間計算量：O(n)　空間計算量：O(n)<br>

## 直面したエラーと解決策
・Warning: Undefined array key 32 in ~ php/solution.php on line 17<br>
→ ハッシュマップ作成時に地震後の配列を走査していなかった<br>
→ (前)`$hashmap[$i]`<br>
→ (後)`$hashmap[$shuffledArr[$i]]`<br>

・出力結果が`int(0)`<br>
→ カウント変数の更新を指定なかった<br>
→ (前)`if ~ $count`<br>
→ (後)`if ~ $count++`<br>

## 改善点
・count()の使用回数の削減<br>
→ count()を複数回使うと、同じ配列長を何度も計算して無駄が生じるため<br>
