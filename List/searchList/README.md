# 数値で構成される配列 numList と値 value を受け取り、配列内にある値のインデックスを返す、searchList という関数をハッシュマップを使って作成する問題

## 条件
・値がリスト内に複数ある場合は先に出てきたインデックスを返すこと<br>
・もし発見されない場合は -1 を返すこと<br>

## 関数の入出力例
入力のデータ型： `integer[] numList, integer value`<br>
出力のデータ型： `integer`<br>

## テストケース
`searchList([3,10,23,3,4,50,2,3,4,18,6,1,-2],23) --> 2`<br>
`searchList([3,10,23,3,4,50,2,3,4,18,6,1,-2],-2) --> 12`<br>
`searchList([3,10,23,3,4,50,2,3,4,18,6,1,-2],100) --> -1`<br>

## 思考プロセス
・numList のハッシュマップを作成する<br>
→ キー:配列の値、値:インデックスのハッシュマップ<br>
・value が一番最初に見つかったインデックスを返す<br>
→ ハッシュマップ作成時のループで場合分けを行なう<br>
→ 既に同じ数字がある場合は処理をスキップ、または、インデックスを更新しない必要がある<br>

## 考えられるエッジケース
・numList が空配列<br>

## 悩んだ箇所
・特になし<br>

## 気づき
・floor関数を使わずに、intでキャストする方法があること<br>
・前回の問題で学んだことを活かすことができたこと<br>
→ 変数をなるべく新たに作成せず、使いまわせるなら使いまわせるようにするため、最初に変数を宣言した<br>

## 計算量
JS<br>                                                                        
(予想)時間計算量：O(n)　空間計算量：O(n)<br>
・時間計算量：ハッシュマップ作成時のループ処理による全探索が一度行われるため<br>
・空間計算量：hashmap作成時に、ハッシュマップ配列に対して要素分の追加があるため<br>
(結果)時間計算量：O(n)　空間計算量：O(n)<br>

## 直面したエラーと解決策
・出力の値がテストケースすべてで「-1」<br>
→ ハッシュマップに格納するキーが正しくなかった<br>
→ （前）`hashmap[i] = i`<br>
→ （後）`hashmap[numList[i]] = i`<br>

## 改善点
・ハッシュマップを作成せずに処理する<br>
→ インデックスを返すことが目的であるためindexOfメソッドでも対応できること<br>
※ただし、今回はハッシュマップの活かし方を学ぶために、ハッシュマップを採用している<br>
