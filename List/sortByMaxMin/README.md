# 整数によって構成される配列が与えられるので、最初の最大値の後に最初の最小値、2 番目の最大値の後に 2 番目の最小値、といったように値を並べ替えてから返す sortByMaxMin という関数を作成する問題

## 関数の入出力例
入力のデータ型： `integer[] arr`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`sortByMaxMin([6,2,3,5,8,4]) --> [8,2,6,3,5,4]`<br>
`sortByMaxMin([11,15,9,7,12]) --> [15,7,12,9,11]`<br>
`sortByMaxMin([85,69,56,61,78]) --> [85,56,78,61,69]`<br>
`sortByMaxMin([1,2,3]) --> [3,1,2]`<br>

## 思考プロセス → やったこと
書き方を変えてみた<br>
・配列を昇順にし、配列の要素の最後→最初の順に同時に取り出せば要件を満たすことができる<br>
→ 配列を昇順にした<br>
→ ループ1回の中で完結させようとした。また、配列の前後から処理するので、通常の半分の走査で済ませられる<br>
・配列が偶数のときは問題ないが、奇数のときに、配列の前から行なう処理と後ろから行なう処理でダブってしまう部分が出てくる<br>
→ 奇数の場合は、別の変数を用意しておき、ループ後に配列に追加した<br>

## 悩んだ箇所
・奇数のときに配列の最後に追加する変数をどうやって定義するか<br>
→ 三項演算子を使って、変数にソート後の配列の真ん中の要素 または null を格納するようにした<br>

## 計算量
JavaScript<br>
(予想)時間計算量：O(n) 空間計算量：O(n)<br>
(判断根拠)<br>
・時間計算量：ループ処理を1度行なう、配列の要素数に依存するため<br>
・空間計算量：新たな配列に要素を追加していく処理があり、要素数に依存したメモリ消費があるため<br>
(実際)時間計算量：O(n log n) 空間計算量：O(n)<br>
<br>

PHP<br>
時間計算量：O(n log n)　空間計算量：O(n)<br>
・時間計算量：sort()による影響とループ処理の影響を考慮したため<br>
ループ処理によって n/2 回の反復を行なうが、配列へのアクセスはO(1)
・空間計算量：sort()は元のメモリ内で配置を変えているだけだが、結果用配列に要素数分だけ格納していくため<br>
ただし、参照を使うと、追加のメモリ消費はない。


## 気づき
・sortするロジックをa,bのような変数を使ったアロー関数で表現するということ<br>
・inplaceアルゴリズムを用いると、空間計算量をO(1)に削減できること<br>
・計算量の検証をしてもらった際に、三項演算子を使ったリファクタリング提案を受けて、今回のケースにおける、より簡単な真ん中の数値の決め方を知ったこと<br>

## 工夫した点
・思考プロセスを少しみえるようにしたこと。今後書きながら、よりわかりやすい記述方法を見つけていく。<br>
・配列の要素数が奇数のときは、偶数のときのような処理にはならない点を考慮したこと<br>

## 改善すべき点
・空間計算量の削減<br>
