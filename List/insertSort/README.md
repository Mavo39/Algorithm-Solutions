# 整数で構成される配列 arr が与えられるので、挿入ソートアルゴリズムを実装し、配列を昇順で返す insertionSort という関数を定義する問題


## 関数の入出力例
入力のデータ型： `integer[] arr`<br>
出力のデータ型： `integer[]`<br>


## テストケース
`insertionSort([2,12,5,10,9,8]) --> [2,5,8,9,10,12]`<br>
`insertionSort([1,5,3,4,3,1,6]) --> [1,1,3,3,4,5,6]`<br>
`insertionSort([11,45,32,75,88,15,15]) --> [11,15,15,32,45,75,88]`<br>


## 思考プロセス
ゴール: 挿入ソートアルゴリズムを実装し、配列を昇順に並び替える<br>
必要な要素: ①2重ループによる配列の要素の大小比較 ②入れ替えロジックの実装<br>

①2重ループによる配列の要素の大小比較<br>
あるインデックスを固定して、そのインデックスより前にある要素を順番に比較する<br>
→ 固定しているインデックスより前の要素はソート済みであるため、純粋に固定している要素が前と比べてどうかを見ていけばいい<br>

②入れ替えロジックの実装<br>
固定済みのインデックスの要素とその前の要素を入れ替えていく<br>


## 考えられるエッジケース
・引数が空配列<br>


## 悩んだ箇所
・特になかった<br>


## 計算量
PHP<br>                                                                        
(予想)時間計算量：O(n^2)　空間計算量：O(1)<br>
・時間計算量：2重ループによる処理になるため<br>
・空間計算量：in-place アルゴリズムにより、追加のメモリ消費はない<br>
(結果)時間計算量：O(n^2)　空間計算量：O(1)<br>


## 直面したエラーと解決策
・なし<br>


## 気づき
・一つずつ確認していくことで、固定インデックスより前の要素はソート済みであるという考え方を知ったこと<br>
・実装の意図をコードに込めることの断片を垣間見ることができたこと<br>
→ 挿入ソートのソート済み配列を一つずつずらしていくという意図をコードとしてwhileループを使って表現していた<br>


## 改善点・フィードバック
・挿入ソートの意図であるソート済みの配列をずらして適切な箇所に最後に挿入するという意図を明確にすること<br>
```php: 改善前
    for($i = 1; $i < count($arr); $i++){
        $curr = $arr[$i];
        for($j = $i-1; $j >= 0; $j--){
            if($curr < $arr[$j]){
                $arr[$j+1] = $arr[$j];
                $arr[$j] = $curr;
            }
            else break;
        }
    }
```
```php: 改善後
    for($i = 1; $i < count($arr); $i++){
        $curr = $arr[$i];
        $j = $i - 1;
        while($j >= 0 && $arr[$j] > $curr){
            $arr[$j+1] = $arr[$j];
            $j--;
        }
        $arr[$j+1] = $curr;
    }
```