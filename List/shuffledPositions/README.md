# 異なる数字が並べられたボード arr と、同じ数字がシャッフルされたボード shuffledArr が与えられるので、shuffledArr において、arr の各数字がどのインデックスに移動したかを特定する shuffledPositions という関数を定義する問題

## 例
arr が [2,32,45] で shuffledArr が [45,32,2] の場合、2 はインデックス 0 から 2 へ、32 は 1 から 1 へ、45 は 2 から 0 へ移動したので、結果は [2,1,0] となる。

## 関数の入出力例
入力のデータ型： `integer[] arr, integer[] shuffledArr`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`shuffledPositions([2,32,45],[45,32,2]) --> [2,1,0]`<br>
`shuffledPositions([10,11,12,13],[12,10,13,11]) --> [1,3,0,2]`<br>
`shuffledPositions([10,11,12,13],[10,11,12,13]) --> [0,1,2,3]`<br>
`shuffledPositions([1350,181,1714,375,1331,943,735],[1714,1331,735,375,1350,181,943]) --> [4,5,0,3,1,6,2]`<br>

## 思考プロセス
・arr の数字とシャッフル後の数字のインデックスを関連づける必要がある<br>
→ シャッフル後の配列の数字をキー、インデックスを値としてハッシュマップに格納する<br>
→ 元の配列 arr を走査して、元の配列のインデックスとハッシュマップのインデックスを配列に格納する<br>
→ ハッシュマップを使用することで、O(1)でアクセスできる<br>

## 考えられるエッジケース
・arr が空配列<br>
・shuffledArr が空配列<br>

## 悩んだ箇所
・特になく、すぐにハッシュマップによるアクセスが効率的だと勘付いた<br>

## 計算量
JS<br>                                                                        
(予想)時間計算量：O(n)　空間計算量：O(n)<br>
・時間計算量：ループによる線形探索が最大2回あるが、定数は無視されるため<br>
・空間計算量：hashmap配列に、配列の要素分の追加があるため<br>
(結果)時間計算量：O(n)　空間計算量：O(n)<br>


## 改善点
・エッジケースの条件の書き方<br>
→ JSでは負の長さの配列はないため `=== 0` が適切であること<br>
・可読性の向上<br>
→ res 配列を最初に宣言し、エッジケースでも使用できるようにすることで、余分な変数を用意しなくて済む<br>
