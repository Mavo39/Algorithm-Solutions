# ゲーム中に出現したモンスターのレベルの一覧 levels が与えられるので、最も出現回数が多いレベルを見つけ、そのレベル（または複数のレベル）を昇順に並べた配列として返す appearTheMost という関数を定義する問題

## 例
レベルの一覧が [12,10,9,8,6,3,8,9,9,10] の場合、最も多く出現したレベルは 9 なので、[9] を返す<br>

## 関数の入出力例
入力のデータ型： `integer[] levels`<br>
出力のデータ型： `integer[]`<br>

## テストケース
`appearTheMost([1,1,2,2,3,3,3,4,5,6]) --> [3]`<br>
`appearTheMost([12,10,9,8,6,3,8,9,9,10]) --> [9]`<br>
`appearTheMost([1,1,1,3,3,3,2,2,2,5]) --> [1,2,3]`<br>
`appearTheMost([1,2]) --> [1,2]`<br>
`appearTheMost([100]) --> [100]`<br>
`appearTheMost([1,22,48,500,3000,10000,30,30,30]) --> [30]`<br>

## 思考プロセス
・ハッシュマップの値が大きいもの、かつ、昇順での取り出しは同時にできるか<br>
→ 同時にできるメソッドはない<br>
→ 手順を踏む必要がある<br>
→ ハッシュマップの作成<br>
→ 大きい値を配列に格納する<br>
→ その配列を昇順にソートする<br>

## 考えられるエッジケース
・引数が空配列<br>

## 悩んだ箇所
・昇順をどのタイミングで何に対して行なうかの判断<br>
→ ハッシュマップを作成して各レベルのモンスターの出現回数は求めることができた<br>
→ 最も大きい値をどうやって効率的に求めるかがすぐにはわからなかった<br>
→ ①ハッシュマップの値のみを取り出した配列をつくり<br>
→ ②その配列内での最大値を求める<br>
→ ③ループによって最大値と同じ要素を配列に格納する<br>

## 気づき
・empty()とcount()の使い分けについて学んだ<br>
empty(): 配列が空かどうかを単純に判定したい場合に有効。配列が空の場合だけでなく、null、0、"0"、空文字列 ""、false の場合にも true を返す<br>
count(): 配列の要素数を直接取得するため、「要素が0個である」という条件を明示的に示すことができる<br>
→ これらを踏まえて明確性を重視するため、count()を使用することにした<br>
・array_values()の使い方について
→ 変数に格納する際、その変数は[]などで初期化する必要はない

## 計算量
PHP<br>                                                                        
(予想)時間計算量：O(n)　空間計算量：O(n)<br>
・時間計算量：ループ処理が全部で3回行われるが定数は無視されるため<br>
・空間計算量：配列に対して要素分の追加があるため<br>
(結果)時間計算量：O(n log n)　空間計算量：O(n)<br>
・O(n): forループ, array_values($hashmap), max($values)・O(log n)ksort($hashmap)の合計で上記の時間計算量になる。実際にはループは4回行われる<br>

## 直面したエラーと解決策
・PHP Warning:  Undefined array key 1 in ~ php/solution.php on line 12<br>
→ ハッシュマップに存在しないキーにアクセスしようとした結果<br>
→ キーの存在確認を適切に行なう必要がある<br>
→ array_key_exists()を使った<br>

## 課題
・適切なハッシュマップにおけるキーの存在を確認する方法の使い分け（isset, array_key_exists, == null etc...）<br>

## 改善点
・max()とarray_values()を同時に使用してコードを削減<br>