# 問題
**異なる整数値で構成される二分探索木（BST）の根ノード root が与えられるので、BST 内に存在する最小値を持つノードを返す、minimumNode という関数を作成する問題**

## 問題概要 
**関数の目的**  
BSTの特性を利用して、効率的に最小値のノードを返すこと

## 入出力仕様
**入力**: `binaryTree<integer> root`  
**出力**: `binaryTree<integer>`  

## 要件と制約
### 要件
1. 二分探索木（BST）の探索
2. BSTの性質を利用する
3. 再帰または反復的なアプローチ

### 制約
1. 入力のBSTが正しい形式であること
※`null`を許容すること
2. 出力は、BST内で最小値を持つノード（部分木のルート）

## テストケース
1. `minimumNode(toBinaryTree([null]))--> []`  
2. `minimumNode(toBinaryTree([0,-10,5,null,-3,null,9]))--> [-10,null,-3]`  
3. `minimumNode(toBinaryTree([5,3,6,2,4,null,7]))--> [2]`  
4. `minimumNode(toBinaryTree([-2,-17,8,-18,-11,3,19,null,null,null,-4,null,null,null,25]))--> [-18]`   
5. `minimumNode(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]))--> [-10]`  
6. `minimumNode(toBinaryTree([1,-5,15,-9,-4,10,17,null,-6,null,0,null,14,16,19]))--> [-9,null,-6]`  

## アプローチ
1. minimumNode関数の実装
- rootから左の子ノードが存在するまで処理
→ 左の子ノードは現在のノードより小さいことが前提の構造であるため
- 反復的な処理により実装
- 左の子ノードが存在するとき: 左の子ノードに移動
- 左の子ノードが存在しないとき: その時点でのノードを返す
2. toBinaryTreeの使用
- 配列を二分探索木にする`toBinaryTree`を使用して、ノードを返せるようにする

## 実装方針
- 反復処理を使って実装する

## 想定されるエラー・境界条件（Edge Cases）
- root ノードが `null` のとき: 空（の木）を返す
- ノードが一つだけのとき: 現在のノードを返す
- 左にだけ伸びている: 左端のノードを返す
- 右にだけ伸びている: 現在のノードを返す


## 悩んだ箇所
- 悩んだ箇所は特になかった


## 直面したエラーと解決策
- エラーはなかった


## 気づき
- テストケース作成時に、`binarySubtreeToArray`関数が必要だとわかった


## フィードバック・改善点
- 簡潔で可読性がいいとフィードバックを受けた