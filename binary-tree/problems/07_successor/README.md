# 問題
**異なる整数値で構成される二分探索木（BST）の根ノード root と BST 内に存在する整数 key が与えられるので、根ノードが後続ノードである部分木を返す、successor という関数を作成する問題**  
ただし、そのようなノードが存在しない場合は null を返すこと  

#### 例
ノード N の値を x とした時、後続ノードとは木の中に存在する x よりも大きい最小の値を持つノードのことを指す

## 問題概要 
**関数の目的**  
BSTの特性を利用して、効率的に根ノードの後続ノードである部分木を返すこと


## 入出力仕様
**入力**: `binaryTree<integer> root, integer key`  
**出力**: `binaryTree<integer>`  


## 要件と制約
### 要件
1. 二分探索木（BST）の探索
2. BSTの性質を利用する
3. 再帰または反復的なアプローチ

### 制約
1. 入力のBSTが正しい形式であること
※`null`を許容すること
2. 出力は、BST内で最小値を持つノード（部分木のルート）


## テストケース
1. `successor(toBinaryTree([0,-10,5,null,-3,null,9]), 5)--> [9]`  
2. `successor(toBinaryTree([5,3,6,2,4,null,7]), 5)--> [6,null,7]`  
3. `successor(toBinaryTree([10,6,12,4,8,null,null,2]), 12)--> []`  
4. `successor(toBinaryTree([10,6,12,4,8,null,null,2]), 2)--> [4,2]`   
5. `successor(toBinaryTree([5,4,null]), 5)--> []`  
6. `successor(toBinaryTree([-2,-17,8,-18,-11,3,19,null,null,null,-4,null,null,null,25]), 8)--> [19,null,25]`  
7. `successor(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]), 6)--> [8]`  
8. `successor(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]), 3)--> [5]`  
9. `successor(toBinaryTree([1,-5,15,-9,-4,10,17,null,-6,null,0,null,14,16,19]), 10)--> [14]`  
10. `successor(toBinaryTree([0,-10,5,null,-3,null,9]), -3)--> [0,-10,5,null,-3,null,9]`  


## アプローチ
1. successor関数の実装
目的: keyに該当するノードより大きく、かつ、その中で最小のノードを返すこと
- 必要な要素①: keyに該当するノード（以下、対象ノード）より大きいこと
- 必要な要素②: ①の中で最も小さいこと
【条件①】対象ノードに右の子ノードがある場合 かつ その右の子ノードに左の子ノードがある場合  
    → 最も左に存在するノードが最小値
【条件②】対象ノードに右の子ノードがある場合 かつ その右の子ノードに左の子ノードがない場合  
    → 最も左に存在するノードが最小値
【条件③】対象ノードに右の子ノードがない場合: 対象ノードの親ノード  
方法: 反復的な処理により実装

2. `toBinaryTree`関数の使用
目的: 配列を二分探索木にする`toBinaryTree`を使用して、ノードを返せるようにする

3. `binarySubTreeToArray`関数の使用
目的: 求めた部分木を配列に変換するため

## 実装方針
- 反復処理を使って実装する

## 想定されるエラー・境界条件（Edge Cases）
- root ノードが `null` のとき: `null`を返す
- keyが存在しないとき: 現在のノードを返す
- 対象ノードに親がいない かつ 右の子がいないとき: `null`を返す


## 悩んだ箇所


## 直面したエラーと解決策


## 気づき


## フィードバック・改善点
