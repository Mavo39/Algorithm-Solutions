# 問題
**異なる整数値で構成される二分探索木（BST）の根ノード root と BST 内に存在する整数 key が与えられるので、根ノードが後続ノードである部分木を返す、successor という関数を作成する問題**  
ただし、そのようなノードが存在しない場合は null を返すこと  

#### 例
ノード N の値を x とした時、後続ノードとは木の中に存在する x よりも大きい最小の値を持つノードのことを指す

## 問題概要 
**関数の目的**  
BSTの特性を利用して、効率的に根ノードの後続ノードである部分木を返すこと


## 入出力仕様
**入力**: `binaryTree<integer> root, integer key`  
**出力**: `binaryTree<integer>`  


## 要件と制約
### 要件
1. 二分探索木（BST）の探索
2. BSTの性質を利用する
3. 再帰または反復的なアプローチ

### 制約
1. 入力のBSTが正しい形式であること
※`null`を許容すること
2. 出力は、BST内で最小値を持つノード（部分木のルート）


## テストケース
1. `successor(toBinaryTree([0,-10,5,null,-3,null,9]), 5)--> [9]`  
2. `successor(toBinaryTree([5,3,6,2,4,null,7]), 5)--> [6,null,7]`  
3. `successor(toBinaryTree([10,6,12,4,8,null,null,2]), 12)--> []`  
4. `successor(toBinaryTree([10,6,12,4,8,null,null,2]), 2)--> [4,2]`   
5. `successor(toBinaryTree([5,4,null]), 5)--> []`  
6. `successor(toBinaryTree([-2,-17,8,-18,-11,3,19,null,null,null,-4,null,null,null,25]), 8)--> [19,null,25]`  
7. `successor(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]), 6)--> [8]`  
8. `successor(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]), 3)--> [5]`  
9. `successor(toBinaryTree([1,-5,15,-9,-4,10,17,null,-6,null,0,null,14,16,19]), 10)--> [14]`  
10. `successor(toBinaryTree([0,-10,5,null,-3,null,9]), -3)--> [0,-10,5,null,-3,null,9]`  


## アプローチ
1. successor関数の実装
目的: keyに該当するノードより大きく、かつ、その中で最小のノードを返すこと
- 必要な要素①: keyに該当するノード（以下、対象ノード）より大きいこと
- 必要な要素②: ①の中で最も小さいこと
【条件①】対象ノードに右の子ノードがある場合 かつ その右の子ノードに左の子ノードがある場合  
    → 最も左に存在するノードが最小値
【条件②】対象ノードに右の子ノードがある場合 かつ その右の子ノードに左の子ノードがない場合  
    → 最も左に存在するノードが最小値
【条件③】対象ノードに右の子ノードがない場合: 対象ノードの親ノード  
方法: 反復的な処理により実装

2. `toBinaryTree`関数の使用
目的: 配列を二分探索木にする`toBinaryTree`を使用して、ノードを返せるようにする

3. `binarySubTreeToArray`関数の使用
目的: 求めた部分木を配列に変換するため

## 実装方針
- 反復処理を使って実装する

## 想定されるエラー・境界条件（Edge Cases）
- root ノードが `null` のとき: `null`を返す
- keyが存在しないとき: 現在のノードを返す
- 対象ノードに親がいない かつ 右の子がいないとき: `null`を返す


## 悩んだ箇所
- 後続ノードを表現する方法
→ そもそものアプローチ方法が間違えていた
- 対象ノードの右に存在する場合と左に存在する場合で後続ノードが異なる
→ 右の場合: 子ノードを探っていけば良い  
→ 左の場合: 親ノードが後続ノードになる  
この左の場合における親ノードをどうやって表現するかに苦戦した  
※ 今回は自力でどう実装するかの道筋が見えず、やむをえず過去の回答を参考にした


## 直面したエラーと解決策
```sh
PHP Warning:  Array to string conversion in /path/to/file.php on line 37~
```
【内容】文字列として出力を期待しているが、配列が出力されている  
【原因】PHPは配列を直接文字列として扱うことができないため  
【解決策】`json_encode()`を使用する


## 気づき
- PHPで`json_encode()` を使うと、配列が文字列として扱えるようになるのは、PHPの配列（もしくはオブジェクト）を文字列（JSON形式）に変換しているため
- 実装中に仮説が間違っていることに気づいたが、何がネックになっているのかがわからない状況を自力で打破することができなかった
- 対象ノードを見つける関数・最小ノードを見つける関数を別に用意し、それを再利用するという発想に至れなかったことに気づいた

## フィードバック・改善点
