# 問題

**異なる整数値で構成されるソート済みのリスト numberList が与えられるので、平衡二分探索木を作成し、その根ノードを返す、sortedArrToBST という関数を作成する**  


## 問題概要 

**関数の目的**  
- 高さができるだけ小さい二分探索木（BST）を作ること
- 与えられたソート済み配列（昇順）を使って、バランスの良いBSTを構築すること


## 入出力仕様

**入力**: `integer[] numberList`  
**出力**: `binaryTree<integer>`  


## アルゴリズムの概要

分割統治法を使い、ソート済み配列の中央を根ノードとし、左右の部分配列から再帰的に平衡な二分探索木（BST）を構築します。  
再帰の終了条件を明確に設けることで、葉ノードを自然に構築できる設計にしました。  

## 設計のポイント

### 分割統治法を使用した理由
ソート済みの配列を中央で分割し、左右それぞれを再帰的に同じ処理で構築する構造が、分割統治法の特徴と一致していたため

### 真ん中を根ノードとした理由
平衡な二分探索木を構築するためにはソート済みの配列において中央の値を根ノードとすることで、左右に均等な要素数が割り振ることができると考えたため

### 再帰処理を選定した理由
分割統治法では同じ処理を繰り返し適用するため、再帰との相性がよく、処理の流れが自然に実装できると判断したため


## テストケース
1. `sortedArrToBST([1,2,3])--> [2,1,3]`  
2. `sortedArrToBST([1,2,3,5,6,9,10])--> [5,2,9,1,3,6,10]`  
3. `sortedArrToBST([-1,0,3,10,13,19,22])--> [10,0,19,-1,3,13,22]`  
4. `sortedArrToBST([1,3,4,5,8])--> [4,1,5,null,3,null,8]`   
5. `sortedArrToBST([1,4,6,10,11,14,15,20,22,25,50,61,68,72])--> [15,6,50,1,11,22,68,null,4,10,14,20,25,61,72]`  


## 想定されるエラー・エッジケース
- 配列が空: `null`を返す
- 左の子ノード または 右の子ノードが存在しない: その部分木に対応するノードは `null` として処理し、木構造上には何も追加しない


## 悩んだ箇所

- 再帰処理を実装すること
過去の問題を見返して、関数の呼び出しと戻りを紙に書いて、現在なんの処理をしているのかを整理して進めたことでコードに落とし込んだ


## 直面したエラーと解決策

- 葉ノード以下に不要な`null`がついていたこと

【原因】`binarySubtreeToArray`関数のロジックに一部誤りがあったこと  

【解決策】whileループ内の処理ロジックを変更  

```js
// 変更前
    while(queue.length > 0){
        const current = queue.shift();
        result.push(current.data);

        if(current.left !== null){
            queue.push(current.left);
        } else {
            result.push(null);
        }
        
        if(current.right !== null){
            queue.push(current.right);
        } else {
            result.push(null);
        }
    }

// 変更後
    while(queue.length > 0){
        const current = queue.shift();

        if(current === null){
            result.push(null);
            continue;
        }

        result.push(current.data);
        queue.push(current.left);
        queue.push(current.right);
    }
```

## 気づき

- 過去に実装した二分木を配列として表示する`binarySubtreeToArray`関数のロジックを見返したときに、可読性が悪く、不要な記述がたくさんあることに気づいた
今回、使用している中でロジックの不備に気づいたことがきっかけとなった
- 定期的に過去に書いたロジックも見返すことで、どう変更すると可読性が良くなるのか、保守性はいいのか、といった観点をもって変更することができるとわかった
- 何を繰り返すとどんな結果が期待できるか、という分割統治法と再帰の特性を生かして実装するときに必要な視点を整理することができた


## フィードバック・改善点

- リストの中身がないときの書き方（任意）

```js
if (numberList.length === 0) return null;
// ↓ より短く
if (!numberList.length) return null;
```