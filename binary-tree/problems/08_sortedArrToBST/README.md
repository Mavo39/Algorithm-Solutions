# 問題

**異なる整数値で構成されるソート済みのリスト numberList が与えられるので、平衡二分探索木を作成し、その根ノードを返す、sortedArrToBST という関数を作成する**  


## 問題概要 

**関数の目的**  
- 高さができるだけ小さい二分探索木（BST）を作ること
- 与えられたソート済み配列（昇順）を使って、バランスの良いBSTを構築すること


## 入出力仕様

**入力**: `integer[] numberList`  
**出力**: `binaryTree<integer>`  


## アルゴリズムの概要

分割統治法を使い、ソート済み配列の中央を根ノードとし、左右の部分配列から再帰的に平衡な二分探索木（BST）を構築します。  
再帰の終了条件を明確に設けることで、葉ノードを自然に構築できる設計にしました。  

## 設計のポイント

### 分割統治法を使用した理由
ソート済みの配列を中央で分割し、左右それぞれを再帰的に同じ処理で構築する構造が、分割統治法の特徴と一致していたため

### 真ん中を根ノードとした理由
平衡な二分探索木を構築するためにはソート済みの配列において中央の値を根ノードとすることで、左右に均等な要素数が割り振ることができると考えたため

### 再帰処理を選定した理由
分割統治法では同じ処理を繰り返し適用するため、再帰との相性がよく、処理の流れが自然に実装できると判断したため


## テストケース
1. `sortedArrToBST([1,2,3])--> [2,1,3]`  
2. `sortedArrToBST([1,2,3,5,6,9,10])--> [5,2,9,1,3,6,10]`  
3. `sortedArrToBST([-1,0,3,10,13,19,22])--> [10,0,19,-1,3,13,22]`  
4. `sortedArrToBST([1,3,4,5,8])--> [4,1,5,null,3,null,8]`   
5. `sortedArrToBST([1,4,6,10,11,14,15,20,22,25,50,61,68,72])--> [15,6,50,1,11,22,68,null,4,10,14,20,25,61,72]`  


## 想定されるエラー・エッジケース
- 配列が空: `null`を返す
- 左の子ノード または 右の子ノードが存在しない: その部分木に対応するノードは `null` として処理し、木構造上には何も追加しない


## 悩んだ箇所


## 直面したエラーと解決策


## 気づき


## フィードバック・改善点

