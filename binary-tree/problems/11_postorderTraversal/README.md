# 問題

**整数で構成される二分木の根ノード root が与えられるので、後順を表す配列を返す、postorderTraversal という関数を作成する** 

## 関数の目的

与えられた二分木の根ノードから、後順で走査した結果を配列として返すこと

## この問題に取り組む目的

木構造の走査における「後順走査」を実装できるようにすること

## 入出力仕様

**入力**: `binaryTree<integer> root` 
**出力**: `integer[]` 

## テストケース
1. `postorderTraversal(toBinaryTree([0,-10,5,null,-3,null,9]))--> [-3,-10,9,5,0]` 
2. `postorderTraversal(toBinaryTree([5,3,6,2,4,null,7]))--> [2,4,3,7,6,5]` 
3. `postorderTraversal(toBinaryTree([-2,-17,8,-18,-11,3,19,null,null,null,-4,null,null,null,25]))--> [-18,-4,-11,-17,3,25,19,8,-2] ` 
4. `postorderTraversal(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]))--> [-10,-4,-7,0,2,1,-3,5,8,6,15,19,18,13,3]`  
5. `postorderTraversal(toBinaryTree([1,-5,15,-9,-4,10,17,null,-6,null,0,null,14,16,19]))--> [-6,-9,0,-4,-5,14,10,16,19,17,15,1]` 
6. `postorderTraversal(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]))--> [-10,-4,-7,0,2,1,-3,5,8,6,15,19,18,13,3]`

## 想定されるエラー・エッジケース

- root が `null`: 空配列を返す

## 前提知識

**後順走査** 
ノードの探索順 
1. 左の子ノード
2. 右の子ノード
3. 根ノード

## 仮説・検証

### 仮説

後順走査は「左→右→根」という処理を全ノードに適用する構造であるため、再帰が自然に対応できる

#### 実装方針
  
**構造** 
再帰関数を使って後順走査を実装する 
  
**状態（結果）を保持する場所** 
間順の走査結果を配列に格納する必要があるため、補助関数内で参照渡しされた配列を更新していく 
  
**関数の役割分担** 
メイン関数: 配列の初期化、結果配列を補助関数経由で返す
補助関数: 再帰処理による配列の更新を行ない、処理結果の配列を返す

#### この実装方針にした理由

- 処理内容である、配列の返却・配列の状態管理・再帰処理を一つの関数で行なうと見通しが悪くなってしまうため 

### 検証

仮説に基づいた実装により、期待通りの結果が得られた

## ふりかえり

- 再帰処理において、ベースケースの設定を忘れてしまうと無限ループになってしまうことがわかったので注意したい
メイン関数で null チェックをしているので補助関数では同じ処理をしなくていいのでは？と思い、補助関数では同処理を省いた。  
しかし、再帰処理であるため、ベースケースが見つからず、無限ループという事態に陥った

- PHPの配列（Array）は「連想配列」なので、キーが明示されているかどうかの以下のように挙動が変わることを知った
① キー（インデックス）が明示的に指定されていればそのキーを使う  
② キーが指定されていない（数値添字がない）場合は、PHPが自動で連続した数値キー（0,1,2,...）を割り当てる  

- 自動テストの実装において、後順走査の結果配列をどのように扱うか悩んだ
→ テストケースを連想配列として、入力配列と期待結果をセットで管理するという発想に至らなかった  
※ 時間内に解決できなかったため、AIに相談し、テストの構造化方法を学んだ  


## 直面したエラーと解決策

- 無限ループ
【原因】補助関数におけるベースケースの不足  
【解決策】null のときに配列を返す、ベースケースの追加　 

## フィードバック・改善点

- メイン関数で `if($node === null) return $arr;` を削除
補助関数で行なっているので、わざわざ書く必要はない  
